#!/usr/bin/python3
# coding=utf-8
"""A tool to inject lines into SAFE patches."""

import re
import os
import subprocess
import sys

hook_path = './patch_patch_hook'

if len(sys.argv) != 3:
    print("usage:", sys.argv[0], "input-patch output-patch")
    print()
    print("  This script takes a mutant patch generated by SAFE "
          "and adds further patch-lines to it.")
    print("  The output is written to output-patch, "
          "overwriting it if it already exists.")
    print()
    print("  The lines to add are obtained from a hook called as")
    print("    ", hook_path, "<module> <mutation type> <mutation nr>")
    print("  of which the output is injected into the patch.")
    print()
    print("  The input-patch filename is expected to be as the SAFE tool "
          "outputs it, in order to parse the information "
          "that is passed to the hook.")
    sys.exit(1)

ipatch_path = sys.argv[1]
opatch_path = sys.argv[2]
patch_name = os.path.basename(ipatch_path)
matches = re.match(r'^([-\w]+)\.(?:i_(\w+)_(\d+)\.)+patch$', patch_name).groups()
mod_name = matches[0]
fault = matches[1:]

# Types of faults:
# OMFC  - missing function call
# OMVIV - missing variable initialization (using a value)
# OMVAV - missing variable assignment (using a value)
# OMVAE - missing variable assignment (using an expression)
# OMIA  - missing if construct around statements
# OMIFS - missing if construct plus statements
# OMIEB - missing if construct plus statements plus else before statements
# OMLAC - missing AND EXPR in expression used as branch condition
# OMLOC - missing OR EXPR in expression used as branch condition
# OMLPA - missing small and localized part of algorithm
# OWVAV - wrong value assigned to variable
# OWPFV - wrong variable used in parameter of function call
# OWAEP - wrong arithmetic expression in parameter of a function call
# See Emulation of Software Faults by João Durães & Henrique Madeira.

def call_hook():
    """Call the hook to obtain the string to insert into the patch."""
    # hook is called as
    # ./patch_patch_hook <module> <mutation type> <mutation nr>
    hook = (hook_path, mod_name) + fault
    proc = subprocess.Popen(hook, stdout=subprocess.PIPE,
                            universal_newlines=True)
    add_lines = ''.join(('+' + l for l in proc.stdout))
    if proc.wait() != 0:
        raise RuntimeError('hook returned with code', proc.returncode, hook)
    return add_lines

patchheader_re = re.compile(r'(.*,)(\d+)( @@)')

# We should be able to just add the notification before any fault injection.
# The worst that might happen is a c90 compatibility warning
# due to mixing declaration and code.
with open(ipatch_path) as ipatch,\
     open(opatch_path, 'w') as opatch:
    patch_line = call_hook()
    patch_iter = iter(ipatch)
    # skip file names
    for _ in range(2):
        opatch.write(next(patch_iter))

    def is_patching_line(line):
        """Checks if a line in patch-syntax introduces changes."""
        return line[0] == '-' or line[0] == '+'

    line = next(patch_iter)
    # skip until addition or removal
    # quick check for patch header
    while not line[0] == '@':
        opatch.write(line)
        line = next(patch_iter)
    line = patchheader_re.match(line).groups()
    # increment line count
    line = line[0] + str(int(line[1]) + patch_line.count('\n')) + line[2] + '\n'
    while not is_patching_line(line):
        opatch.write(line)
        line = next(patch_iter)

    # add hook
    opatch.write(call_hook())

    # write all the rest
    def checked_write(line):
        """Warns about difficult patch lines before writing them."""
        if is_patching_line(line) and "if" in line:
            print("Warning: patch contains a modified if-statement. "
                  "The code added by the hook may not execute when intended.")
        opatch.write(line)

    checked_write(line)
    for line in patch_iter:
        checked_write(line)
