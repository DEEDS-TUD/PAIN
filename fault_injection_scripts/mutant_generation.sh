#!/bin/sh

# little helper to script location
THIS_SCRIPT_INVOCATION=$0
printf %s\\n "This script has been invoked as $THIS_SCRIPT_INVOCATION"
THIS_SCRIPT_PATH=$(readlink -e $THIS_SCRIPT_INVOCATION)
THIS_SCRIPT_DIR=$(dirname $THIS_SCRIPT_PATH)

# check env setup
[ -z "$AFI_HOME" ] && { \
  . "$THIS_SCRIPT_DIR/../env.sh" || \
    { echo "ERROR: Invalid environment setup."; exit 1; };
}

#prerequisites:
#	original_target_file
#	degree

if [ $# -ne 2 ]; then
    echo
    echo Invalid command line arguments.
    echo Usage: ./generate_mutants.sh target_file simultaneity_degree
    exit 1
fi
if [ ! -r $1 ]; then
    echo Target file $1 does not exist or is not readable.
    exit 1
fi
if [ $2 -le 0 ]; then
    echo "Simultaneity degree <= 0 is invalid."
    exit 1
fi

exec >mutant_generation.log 2>&1

ORIGINAL_TARGET_FILE=$(readlink -e "$1")

echo "Original target file: $ORIGINAL_TARGET_FILE"

DEGREE="$2"

echo "Degree: $DEGREE"

KERNEL_DIR=$AFI_KERNEL_HOME

echo "Kernel dir: $KERNEL_DIR"

KERNEL_VERSION=$(head -2 ../goldfish_kernel/Makefile|sed 's/.* = //g'|tr '\n' '.'|sed 's/\.$//')

echo "Kernel version: $KERNEL_VERSION"

SCRIPT_HOME=$(pwd)
# for the patch-tool
DIR_DEPTH=$(echo "$SCRIPT_HOME"|tr '/' '\n'|wc -l)

echo "Script home: $SCRIPT_HOME (on fs-depth $DIR_DEPTH)"

MODULE_SRC=$(basename "$ORIGINAL_TARGET_FILE")
MODULE_NAME=$(basename "$MODULE_SRC" .c)
MODULE_PATH=${ORIGINAL_TARGET_FILE%.c}.ko

TARGET_DIR=$MODULE_NAME

echo "Target dir: $TARGET_DIR"

# prepare the script directory
#cp -v $ORIGINAL_TARGET_FILE $SCRIPT_HOME
for d in patch_backup target_file_backup order_0_mutants; do
	mkdir -pv "$TARGET_DIR"/"$d"
done
cp -v "$ORIGINAL_TARGET_FILE" "$TARGET_DIR"/order_0_mutants

# prepare the kernel directory
cp -v ../config/Makefile.target.${KERNEL_VERSION} ${KERNEL_DIR}/Makefile

# build mutants
for DEGREE in $(seq 1 $DEGREE); do
	echo "Starting round $DEGREE"
	
	BASE_MUTANTS_DIR="$TARGET_DIR"/order_${DEGREE}_mutants
	BASE_BACKUP_DIR="$TARGET_DIR"/patch_backup/order_${DEGREE}_mutants
	mkdir -pv "$BASE_MUTANTS_DIR"
	mkdir -pv "$BASE_BACKUP_DIR"
	
	# create mutants from all mutants of the previous round
	for BASE_MUTANT_PATH in $(find "$TARGET_DIR"/order_$((DEGREE-1))_mutants -type f -name '*.c'); do
		echo "Processing mutant $BASE_MUTANT_PATH"
		
		BASE_MUTANT=$(basename "$BASE_MUTANT_PATH")
		BASE_MUTANT_NAME=${BASE_MUTANT%.c}
		MUTANTS_DIR="$BASE_MUTANTS_DIR"/"$BASE_MUTANT"_mutants
		BACKUP_DIR="$BASE_BACKUP_DIR"/"$BASE_MUTANT"_mutants
		
		mkdir -pv "$MUTANTS_DIR"
		mkdir -pv "$BACKUP_DIR"
		mkdir -pv "$BACKUP_DIR"/skipped
		
		# create preprocessed .i file
		cp "${BASE_MUTANT_PATH}" .
		MODULE_OBJ="$BASE_MUTANT_NAME".o
		MODULE_PP="$BASE_MUTANT_NAME".i
		echo "make command line is: make -f Makefile.mutant obj-m=\"$MODULE_OBJ\""
		EXTRA=-I${AFI_KERNEL_HOME}/block
		make -f Makefile.mutant obj-m="$MODULE_OBJ" EXTRA=${EXTRA}
		if [ $? -ne 0 ]; then
			echo "make failed for mutant $BASE_MUTANT_PATH" #>> ${SCRIPT_HOME}/create_homs_degree_${DEGREE}.log
			continue
		else
			mv -v "$KERNEL_DIR"/"$MODULE_PP" "$SCRIPT_HOME"/"$MODULE_PP"
		fi
		
		# post-process .i file and invoke SAFE
		echo "Invoking tool.sh \"$MODULE_PP\""
		./tool.sh "$MODULE_PP"
		
		# create mutants from all patches generated by SAFE _IF_ they apply for the targeted file
		for MUTANT_PATCH in $(find "$BASE_MUTANT_NAME"_patch/ -type f -name '*.patch'); do
			echo "Processing patch $MUTANT_PATCH"
			
			PATCHED_FILE=$(cat "$MUTANT_PATCH"|sed '1 s/^--- //;q')
			if [ -z "$PATCHED_FILE" ]; then
				echo "Unable to parse patch $PATCHED_FILE"
				echo "  (invalid header)"
				mv -v "$MUTANT_PATCH" "$BACKUP_DIR"/skipped
				continue
			fi
			if [ "$PATCHED_FILE" != "$(readlink -e "$BASE_MUTANT")" ]; then
				echo "Skipping patch file $MUTANT_PATCH for $PATCHED_FILE"
				mv -v "$MUTANT_PATCH" "$BACKUP_DIR"/skipped
				continue
			fi
			
			# prepare patch-patching
			PATCHED_PATCH="$MUTANT_PATCH".sup
			# apply modifications to patch
			PATCHOUT=$(python patch_patch.py "$MUTANT_PATCH" "$PATCHED_PATCH")
			if [ $? -ne 0 ]; then
				echo "Patching the patch failed:"
				echo $PATCHOUT
				rm -vf "$PATCHED_PATCH"
				continue
			fi
			
			mv -v "$PATCHED_PATCH" "$MUTANT_PATCH"
			
			patch -f --dry-run -p"$DIR_DEPTH" \
				-i "$MUTANT_PATCH"
			if [ $? -ne 0 ]; then
				echo "Unable to apply patch: $MUTANT_PATCH" #>> create_homs_degree_${DEGREE}.log
			else
				patch -f -p"$DIR_DEPTH" \
					-o "$MUTANTS_DIR"/"$(basename ${MUTANT_PATCH%.patch}.c)" \
					-i "$MUTANT_PATCH"
				mv -v "$MUTANT_PATCH" "$BACKUP_DIR"
			fi
		done
		
		# clean & remove patch_folder
		# keep .ko?
		make -f Makefile.mutant obj-m="$MODULE_OBJ" clean
		#rm -vr "$BASE_MUTANT_NAME"_patch
		rm "$BASE_MUTANT"
		mv -v "$MODULE_PP" "$TARGET_DIR"/target_file_backup/order_$((DEGREE-1))_mutant.i
	done # degree i-1 mutants
done # degree

# reset the kernel directory
cp -v ../config/Makefile.kernel.${KERNEL_VERSION} ${KERNEL_DIR}/Makefile

echo "Mutant generation finished!"
